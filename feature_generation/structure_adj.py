import numpy as np
import matplotlib.pyplot as plt
import os
import math

CONNECT_THRESHOLD = 8
INCOMPARABLE_PAIR = 100000


def juli(x1, x2):
    juli = float(math.sqrt((x1[0] - x2[0]) ** 2 + (x1[1] - x2[1]) ** 2 + (x1[2] - x2[2]) ** 2))
    return juli

def get_distance_matrix(pdbfile):
    C_alpha_cordinate = []
    f = open(pdbfile, 'r')
    pdb_data = f.readlines()
    for line in pdb_data:
        if line[0:3] == 'END':
            break
        if line[0:4] == 'ATOM' and line[13] == 'C' and line[14] == 'A' and line[21] == 'A':
            pos = [eval(line[30:38]), eval(line[38:46]), eval(line[46:54])]
            C_alpha_cordinate.append(pos)
        if line[0:3] == 'TER':
            protein_length = eval(line[22:26])

    length = len(C_alpha_cordinate)
    print(length)
    C_alpha_cordinate = np.array(C_alpha_cordinate)
    """
    construct distance matrix for protein
    """
    assert protein_length == length
    dis_matrix = np.zeros((length, length), np.float)
    for i in range(length):
        for j in range(i, length):
            dis_matrix[i, j] = juli(C_alpha_cordinate[i], C_alpha_cordinate[j])
            dis_matrix[j, i] = dis_matrix[i, j]

    """
    only for P01327, because it has 'X' in sequence, so we need to reconstruct its distance matrix
    """
    # insert_row = np.array([INCOMPARABLE_PAIR] * length)
    # insert_col = np.array([INCOMPARABLE_PAIR] * protein_length)
    #
    # dis_matrix = np.insert(dis_matrix, 30, values=insert_row, axis=0)
    # dis_matrix = np.insert(dis_matrix, 31, values=insert_row, axis=0)
    # dis_matrix = np.insert(dis_matrix, 63, values=insert_row, axis=0)
    # dis_matrix = np.insert(dis_matrix, 64, values=insert_row, axis=0)
    #
    # dis_matrix = np.insert(dis_matrix, 30, values=insert_col, axis=1)
    # dis_matrix = np.insert(dis_matrix, 31, values=insert_col, axis=1)
    # dis_matrix = np.insert(dis_matrix, 63, values=insert_col, axis=1)
    # dis_matrix = np.insert(dis_matrix, 64, values=insert_col, axis=1)
    #
    # for i in range(protein_length):
    #     if i == 30 or i == 31 or i == 63 or i == 64:
    #         dis_matrix[i][i] = 0

    return dis_matrix, length


def create_matrix(number, amount):
    matrix = []
    for i in range(0, number):
        tmp = []
        for j in range(0, number):
            tmp.append(amount)
        matrix.append(tmp)
    return matrix


def create_adj(A, threshold):
    # Create CMAP from distance
    n = len(A)
    adjacent_matrix = create_matrix(n, 0)
    for i in range(len(A)):
        for j in range(len(A)):
            if i == j:
                continue
            else:
                dis = juli(A[i], A[j])
                cutoff = threshold
            if dis < cutoff:
                adjacent_matrix[i][j] = 1
                adjacent_matrix[j][i] = 1
    return np.array(adjacent_matrix)


def min_k(arr, k):
    arr_cp = list(arr)
    index_k = []
    neibor_count = 0
    # the distance of unreachable residues was set as INF
    for i in range(len(arr_cp)):
        if arr_cp[i] >= 8 or arr_cp[i] == 0:
            arr_cp[i] = float('inf')
        else:
            neibor_count += 1
    # the nearset k residues
    k = min(neibor_count, k)
    for i in range(k):
        index_i = arr_cp.index(min(arr_cp))
        index_k.append(index_i)
        arr_cp[index_i] = float('inf')
    return np.array(index_k)

def get_num_of_neibor(arr):
    count = 0
    for i in range(len(arr)):
        if arr[i] > 0 and arr[i] < 8:
            count += 1
    return count

def get_structure_neibor_feature(protein_fea, current_pos, min_k_inedx, k):
    """
    :param protein_fea:
    :param current_pos: the position of target residue
    :param min_k_inedx: the nearest k residues [len(min_k_index)<=k]
    :param k: the number of structure neighbors we choosed
    :return:
    """
    neibor_fea = []
    current_fea = protein_fea[current_pos]
    fea_length = len(current_fea)
    neibor_k = len(min_k_inedx)
    neibor_fea.append(current_fea)
    if neibor_k == k:
        for i in range(k):
            neibor_fea.append(protein_fea[min_k_inedx[i]])
    else:
        append_zero_num = k - neibor_k
        for i in range(neibor_k):
            neibor_fea.append(protein_fea[min_k_inedx[i]])
        for i in range(append_zero_num):
            neibor_fea.append(np.array([0.]*fea_length, dtype='float32'))
    return np.array(neibor_fea, dtype='float32')


if __name__ == '__main__':

    path = '../feature/train'
    proteins = os.listdir(path)
    k = 8
    for protein in proteins:
        print(protein)
        structure_neibore_fea = []
        protein_fea = np.load(path + '/' + protein + '/' + protein + '_all_fea.npy').astype('float32') # Generated by Resfea.py
        protein_dismatrix = np.load(path + '/' + protein + '/' +protein + '_dis.npy')
        protein_length = len(protein_fea)
        for i in range(protein_length):
            min_k_index = min_k(protein_dismatrix[i], k)
            eachres_neibor_fea = get_structure_neibor_feature(protein_fea, i, min_k_index, k)
            assert len(eachres_neibor_fea) == k + 1
            structure_neibore_fea.append(eachres_neibor_fea)
        structure_neibore_fea = np.array(structure_neibore_fea, dtype='float32')
        np.save(path+'/'+protein+'/'+protein+'_neibor.npy', structure_neibore_fea)
    print('Done!')












